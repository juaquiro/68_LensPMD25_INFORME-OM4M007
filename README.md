# LensPMD
Repo for the LensPMD project

## License

This project is released under a **non-commercial academic license**. You are free to use, modify, and distribute it for research and educational purposes, as long as proper attribution is given.

**Commercial use is prohibited** without explicit permission.

See [license.txt](license.txt) for full terms.  
For commercial licensing, please contact: jalonso@iot.es

## Conda enviroment:

run conda activate LENSPMD25-base310 

if not present create enviroment using yml file

## local data
Run download_dropbox_directory.sh to download the local data to /local_data


# MATLAB Code Base

Autogenerated, GitHub‑ready README describing the uploaded MATLAB `.m` files.

---

## Directory

`VisualiceFeatures`

---

## Contents (all `.m` files)

- `DemodHiltert2D.m` — DEMODHILTERT2D demodulated input ingram g using 2D hiltert transform
- `GenTrainingSetSpatialFreqs.m` — Script para la generacion de conjutos de entrenamiento para la medida de la frecuencia espacial local
- `TrainModelMultipleResponse.m` — Regression Learner-style script using fitrnet + validation/test plots
- `VisualiceFeatures.m` — script for checking and visualize features
- `calcFeature.m` — calcFeature(g, featureName) calculates the feature "featureName" of the [NRxNC] patch
- `calcFeatureBatch.m` — calcFeatureBatch  Vectorized feature extractor for a stack of patches.
- `calcSpatialFreqsHilbert2D.m` — calcSpatialFreqsHilbert2D(g, M, wTh, hilbertFilterDirection) calculates
- `calcSpatialFreqsSupervisedRegression.m` — calcSpatialFreqsSupervisedRegression calculates the local spatial freqs,
- `calcSpatialFreqsSupervisedRegressionBatch.m` — calcSpatialFreqsSupervisedRegression (optimized)
- `expandMatrixField.m` — EXPANDMATRIXFIELD Expand a matrix field of a table into separate columns.
- `kfoldCV_fitrnet_multiresponse.m` — Manual K-fold CV for multi-response fitrnet.
- `naturalSort.m` — NATURALSORT Sort cell array of strings with numeric suffixes in natural order.
- `phaseGradient.m` — ======================================================================
- `testMultipleResponsesPredictUsingML.m` — This script verifies a previously trained model created with TrainModelMultipleResponse

---

## Quick Start

1. **Add the folder to your MATLAB path** (recursively):
   ```matlab
   addpath(genpath(pwd))  % run from the repository root
   ```

2. **Run an entry point** (if available), or open a script/function and press **Run** in MATLAB.

**Detected entry points / scripts:**
- DemodHiltert2D.m
- GenTrainingSetSpatialFreqs.m
- TrainModelMultipleResponse.m
- VisualiceFeatures.m
- testMultipleResponsesPredictUsingML.m

---

## MATLAB Version & Toolboxes

- Works on recent MATLAB releases (R2021b+ suggested).
- May use Image Processing / Signal Processing toolboxes depending on your workflow.

---

## Function Reference

### `DemodHiltert2D.m`

**Signature:** `function z = DemodHiltert2D(g, M, wTh, hilbertFilterDirection)`

**Description:** DEMODHILTERT2D demodulated input ingram g using 2D hiltert transform
**Inputs:** `g, M, wTh, hilbertFilterDirection`  
**Outputs:** `z`

Header excerpt:
```matlab
DEMODHILTERT2D demodulated input ingram g using 2D hiltert transform
AQ 11APR24
Copyright 2009 OM4M
```

### `GenTrainingSetSpatialFreqs.m`

**Signature:** `(script)`

**Description:** Script para la generacion de conjutos de entrenamiento para la medida de la frecuencia espacial local
**Calls:** `calcFeatureBatch`, `expandMatrixField`

Header excerpt:
```matlab
Script para la generacion de conjutos de entrenamiento para la medida de la frecuencia espacial local
mediante el uso de metodos de aprendizaje supervisado para regresion
AQ V2 8AUG25
```

### `TrainModelMultipleResponse.m`

**Signature:** `(script)`

**Description:** Regression Learner-style script using fitrnet + validation/test plots
**Calls:** `kfoldCV_fitrnet_multiresponse`

Header excerpt:
```matlab
Regression Learner-style script using fitrnet + validation/test plots
Adjust this to your Excel file path:
```

### `VisualiceFeatures.m`

**Signature:** `(script)`

**Description:** script for checking and visualize features
**Calls:** `calcFeature`, `naturalSort`

Header excerpt:
```matlab
script for checking and visualize features
AQ 14AUG25
clear
```

### `calcFeature.m`

**Signature:** `function [featureVector, S] = calcFeature(g, featureName)`

**Description:** calcFeature(g, featureName) calculates the feature "featureName" of the [NRxNC] patch
**Inputs:** `g, featureName`  
**Outputs:** `[featureVector, S]`

Header excerpt:
```matlab
calcFeature(g, featureName) calculates the feature "featureName" of the [NRxNC] patch
*featureGV is the 1x[NR*NC] vectorized normalized version of the GV
*feature_DFT is the 1x(NR*[floor(0.5*NC)+1]) DFT normalized abs coefiecients
*feature_projectedDFT is the normalized 1x[NR + floor(0.5*NC)+1] DFT abs coefs [Proj(wx) Proj(wy)]
before calculating the features we filter out noise with a gaussian
filter
V1 15AUG25 three features
V2 28AUG25 add a spatial-domain filter to minimize border effects and
make the patch more wavelet-like
```

### `calcFeatureBatch.m`

**Signature:** `function [X_sel, S] = calcFeatureBatch(B, featureName)`

**Description:** calcFeatureBatch  Vectorized feature extractor for a stack of patches.
**Inputs:** `B, featureName`  
**Outputs:** `[X_sel, S]`

Header excerpt:
```matlab
calcFeatureBatch  Vectorized feature extractor for a stack of patches.

[X_sel, S] = calcFeatureBatch(B, featureName)

Inputs
B           : N x M x L array, each page B(:,:,k) is one patch (double/single ok)
featureName : "feature_GV" | "feature_DFT" | "feature_projected_DFT"

Output
X_sel : L x F feature matrix (row i = feature vector of patch i)
S     : (optional) struct with selected intermediates for debugging

Notes
- Mirrors the per-patch logic in calcFeature.m, including:
* DC removal in spatial domain
* Gaussian spatial window W (minimize borders)
* DFT + DC kill at (1,1), fftshift to center
* Gaussian low-pass in frequency domain (same W)
* Semiplane selection wx >= 0, and sign disambiguation along wy
* Normalization by sum(abs(G(:))) per patch
- Entire pipeline is vectorized across the L patches (no loops).
```

### `calcSpatialFreqsHilbert2D.m`

**Signature:** `function [w, wx, wy, MH]=calcSpatialFreqsHilbert2D(g, M, wTh, hilbertFilterDirection, filterFreqsFlag, mn)`

**Description:** calcSpatialFreqsHilbert2D(g, M, wTh, hilbertFilterDirection) calculates
**Inputs:** `g, M, wTh, hilbertFilterDirection, filterFreqsFlag, mn`  
**Outputs:** `[w, wx, wy, MH]`
**Calls:** `DemodHiltert2D`, `phaseGradient`

Header excerpt:
```matlab
calcSpatialFreqsHilbert2D(g, M, wTh, hilbertFilterDirection) calculates
the spatial freq module w and its components wx and wy all in rad/px for
the input igram g with ROI M, wTH is the threshold to filter out low
freqs and hilbertFilterDirection is the hilbert filter direction
```

### `calcSpatialFreqsSupervisedRegression.m`

**Signature:** `function [w_phi, phi_x, phi_y, theta, QM, M_proc]=calcSpatialFreqsSupervisedRegression(g, trainedModel, featureName, M_ROI)`

**Description:** calcSpatialFreqsSupervisedRegression calculates the local spatial freqs,
**Inputs:** `g, trainedModel, featureName, M_ROI`  
**Outputs:** `[w_phi, phi_x, phi_y, theta, QM, M_proc]`
**Calls:** `calcFeature`, `naturalSort`

Header excerpt:
```matlab
calcSpatialFreqsSupervisedRegression calculates the local spatial freqs,
phi_x, phi_y and the module w_phi all in rad/px for the input igram g
with ROI M, using as feature featureName and a matching the trained supervised regression model trainedModel
this method works better for spatial carrier fringe patters with a
carrier oriented about 45º
```

### `calcSpatialFreqsSupervisedRegressionBatch.m`

**Signature:** `function [w_phi, phi_x, phi_y, theta, QM, M_proc] = ...`

**Description:** calcSpatialFreqsSupervisedRegression (optimized)
**Calls:** `calcFeature`, `calcFeatureBatch`, `calcSpatialFreqsSupervisedRegression`

Header excerpt:
```matlab
calcSpatialFreqsSupervisedRegression (optimized)
- Vectorized valid-patch detection (conv2)
- Extract only needed patches (no full im2col)
- Parallel feature computation (parfor if a pool is open)
- Same outputs: w_phi, phi_x, phi_y, theta, QM, M_proc
```

### `expandMatrixField.m`

**Signature:** `function T = expandMatrixField(T, fieldName)`

**Description:** EXPANDMATRIXFIELD Expand a matrix field of a table into separate columns.
**Inputs:** `T, fieldName`  
**Outputs:** `T`

Header excerpt:
```matlab
EXPANDMATRIXFIELD Expand a matrix field of a table into separate columns.

T = expandMatrixField(T, fieldName) expands the matrix stored in the
table variable T.(fieldName) into separate columns. Each new column
will be named "fieldName_1", "fieldName_2", ..., with no spaces.
The original field is removed from the table.

Example:
% Create a table with a matrix field
T = table((1:3)', [1 2 3; 4 5 6; 7 8 9], ...
'VariableNames', {'ID','X'});

% Expand the matrix field "X" into separate columns
T = expandMatrixField(T, 'X');

% Save to Excel without spaces in headers
writetable(T, 'myFile.xlsx');

See also ARRAY2TABLE, WRITETABLE.
```

### `kfoldCV_fitrnet_multiresponse.m`

**Signature:** `function [oofPred, rmsePerResp, rmseOverall] = kfoldCV_fitrnet_multiresponse(X, Y, kfold, opts)`

**Description:** Manual K-fold CV for multi-response fitrnet.
**Inputs:** `X, Y, kfold, opts`  
**Outputs:** `[oofPred, rmsePerResp, rmseOverall]`

Header excerpt:
```matlab
Manual K-fold CV for multi-response fitrnet.
X: N×P predictors (table or matrix compatible with fitrnet)
Y: N×R responses (numeric matrix, R>=2)
kfold: number of folds
opts: struct with fields mirroring fitrnet name-value pairs, e.g.:
opts.LayerSizes = [10 10 10];
opts.Activations = 'relu';
opts.IterationLimit = 1000;
opts.Standardize = true;

Returns:
oofPred: N×R out-of-fold predictions
rmsePerResp: 1×R RMSE computed over all OOF preds
rmseOverall: scalar RMSE over all responses concatenated
```

### `naturalSort.m`

**Signature:** `function D_sorted = naturalSort(D, prefix)`

**Description:** NATURALSORT Sort cell array of strings with numeric suffixes in natural order.
**Inputs:** `D, prefix`  
**Outputs:** `D_sorted`

Header excerpt:
```matlab
NATURALSORT Sort cell array of strings with numeric suffixes in natural order.

D_sorted = naturalSort(D, prefix) sorts the cell array of strings D
according to the numeric value after the specified prefix.

Input:
D      - 1xN cell array of character vectors or strings
prefix - string or char specifying the prefix before the number

Output:
D_sorted - 1xN cell array, sorted in natural numeric order

Example:
% Example input
D = {'X_1','X_10','X_11','X_2','X_3','X_20'};

% Sort using prefix "X_"
D_sorted = naturalSort(D, 'X_');

% Result:
%   {'X_1','X_2','X_3','X_10','X_11','X_20'}

See also SORT, CELLFUN, REGEXP, SSCANF.
```

### `phaseGradient.m`

**Signature:** `function [phix, phiy, Mxy]=phaseGradient(z, M, NS, Nmed, LPCycles)`

**Description:** ======================================================================
**Inputs:** `z, M, NS, Nmed, LPCycles`  
**Outputs:** `[phix, phiy, Mxy]`

Header excerpt:
```matlab
======================================================================
phasor filtering and direct gradient calculation
this function calculates the gradient [phix, phiy] of a phasor's phase, z=b*exp(1i*phi). It uses the same sign convetion that MATLAB gradient().
> Returns a the phase gradient and a Mask with valid differences. For this we use a median filter for outlier removal and gradient after phasor filtering
>
> Nmed median filter size for phase only cosine-sine filtering
> NS 2*NS+1 is the neigbouhoord size for phasor filtering
> M ROI with valid points
> z input phasor z=b*exp(1i*phi)
> LPCycles are the number of low pass cycles that we apply
> to the calculated derivatives
> Mxy ROI with valid differences
> phix phase x-gradient in px^-1
> phiy phase y-gradient in px^-1
======================================================================
```

### `testMultipleResponsesPredictUsingML.m`

**Signature:** `(script)`

**Description:** This script verifies a previously trained model created with TrainModelMultipleResponse
**Calls:** `calcSpatialFreqsSupervisedRegressionBatch`

Header excerpt:
```matlab
This script verifies a previously trained model created with TrainModelMultipleResponse
(Solo comentarios corregidos/clarificados; el código permanece igual)
```

---

## Tips

- **Path issues**: ensure `addpath(genpath(repo_root))` is executed before calling functions.
- **Reproducibility**: set `rng(seed)` when randomness is involved (if applicable).
- **Images**: cast with `im2double` to get `[0,1]` if functions expect normalized grayscale.

---

## License

Add a `LICENSE` file (e.g., MIT).

---

*This README was generated automatically by scanning `.m` headers; refine descriptions as needed.*




# Python part Spatial Frequency Estimation (TF, NumPy) — Base Code

> CNN‑ready feature pipeline and ML inference utilities for estimating **local spatial frequency** on fringe patterns. Includes CPU (NumPy) and GPU (TensorFlow) feature extractors, batch prediction helpers, and a minimal artifact‑based inference script.

---

## Contents

- `ml_spatialfreq_utils.py` — NumPy feature extractor and classic batch regression wrapper.
- `ml_spatialfreq_utils_GPU.py` — TensorFlow/GPU feature extractor + end‑to‑end GPU batch pipeline.
- `predict_tf.py` — Inference from tabular features using saved Keras model, scaler, and meta.
- `LENSPMD25_base310.yml` — Conda environment for Python 3.10 (TensorFlow + scientific stack).
- Notebooks (for training & debugging):
  - `Train_TF_Regression_Multioutput.ipynb`
  - `Predict_TF_SpatialFreqs.ipynb`
  - `DEBUG_Predict_TF_SpatialFreqs.ipynb`

> The notebooks demonstrate model training, feature verification (NumPy vs TF), and profiling.

---

## TL;DR

- **Input:** grayscale image `g` and an optional ROI mask `M_ROI`.
- **Processing:** extract all valid `N×M` patches → window & FFT → keep one spectral semiplane → 1D projections → **feature vector** per patch.
- **Output:** dense maps of `w_phi`, `phi_x`, `phi_y`, `theta`, plus a scalar **quality map** `QM` and the processed‑pixel mask `M_proc`.
- **CPU path:** `calc_feature_batch` → `calc_spatial_freqs_supervised_regression_batch`.
- **GPU path:** `tf_calc_feature_batch` → `calc_spatial_freqs_supervised_regression_batch_gpu`.

---

## Installation

### 1) Create the environment

```bash
conda env create -f LENSPMD25_base310.yml
conda activate lenspmd25-base310
```

### 2) (Optional) GPU check

```python
import tensorflow as tf
print(tf.config.list_physical_devices("GPU"))
```

---

## Quick Start

### Option A — End‑to‑end (GPU) from an image

```python
import numpy as np
from ml_spatialfreq_utils_GPU import calc_spatial_freqs_supervised_regression_batch_gpu
from ml_spatialfreq_utils import TrainedModelTF, DBInfo

# 1) Load your image (H,W) float32 in [0,1] or raw gray
g = np.load("fringe_image.npy").astype(np.float32)

# 2) Describe the trained model (paths point to your saved local_data)
tm = TrainedModelTF(
    model_path="local_data/model.keras",
    scaler_path="local_data/scaler.pkl",
    meta_path="local_data/meta.json",
    DB_info=DBInfo(featureName="feature_projected_DFT", patch_NR=33, patch_NC=33),
)

# 3) Run
w_phi, phi_x, phi_y, theta, QM, M_proc, timings = \
    calc_spatial_freqs_supervised_regression_batch_gpu(
        g, tm, feature_name="feature_projected_DFT", M_ROI=None, return_timing=True
    )

print(timings)
```

### Option B — Inference from tabular features

If you already have features in a `pandas.DataFrame` with the same **predictor** columns used at training time:

```python
import pandas as pd
from predict_tf import predict_from_dataframe

df = pd.read_csv("X_features.csv")  # must contain columns listed in meta["predictorNameList"]

Yhat = predict_from_dataframe(
    df,
    model_dir="local_data/model.keras",
    scaler_pkl="local_data/scaler.pkl",
    meta_json="local_data/meta.json",
)
print(Yhat.head())
```

---

## How it Works (Core Ideas)

### 1) Feature Extraction (NumPy, CPU)

- Build a **spatial Gaussian window** centered at `floor(M/2)+1, floor(N/2)+1` (MATLAB‑style 1‑based centering).
- Remove patch DC, apply the window, FFT on `(rows, cols)`, **zero DC**, `fftshift`.
- Keep the **semiplane** `ωx ≥ 0`; for `ωy`, pick top/bottom half by energy to resolve sign ambiguity.
- Form **1D projections** along X and Y and **row‑normalize** by the spectrum L1 norm.

API:

```python
from ml_spatialfreq_utils import calc_feature_batch
X, S = calc_feature_batch(B, featureName="feature_projected_DFT")  # B: (N,M,L)
```

### 2) Batch Regression Wrapper (CPU)

- Finds all valid `N×M` patch centers within borders and ROI.
- Extracts patches, builds features, **scales** (if a `scaler.pkl` is provided), and predicts with a Keras model.
- **Scatters back** predictions into image‑sized maps and builds a **quality map**  
  `QM = M_proc * (1 - mat2gray(|w_phi - |φx + i φy||))`.

API:

```python
from ml_spatialfreq_utils import calc_spatial_freqs_supervised_regression_batch
w_phi, phi_x, phi_y, theta, QM, M_proc = \
    calc_spatial_freqs_supervised_regression_batch(g, tm, "feature_projected_DFT")
```

### 3) GPU Pipeline & TF‑specific Details

- **Patch extraction** uses `tf.image.extract_patches` for speed.
- **FFT axes:** TensorFlow’s `fft2d` transforms the **last two** axes. To match NumPy’s `(rows, cols)` transform, the code **transposes** to `(L,N,M)`, applies `fft2d`, then transposes back.
- **Async sync:** some TF API (e.g., `tf.experimental.async_wait`) isn’t present on all versions; a tiny helper **materializes to host** to force synchronization.
- **Feature scaling:** detects `scaler.mean_`/`var_` (or `scale_`) and applies robust broadcasting; otherwise falls back to `scaler.transform()`.

API:

```python
from ml_spatialfreq_utils_GPU import tf_calc_feature_batch
Xs, S = tf_calc_feature_batch(B_tf, "feature_projected_DFT")  # B_tf: (N,M,L) float32
```

---

## I/O Contracts

- **Images:** `g` is `float32` `(NR,NC)`; ROI `M_ROI` is boolean `(NR,NC)`.
- **Patch size:** `DBInfo.patch_NR`, `DBInfo.patch_NC` (odd sizes recommended).
- **Features:** shape `(L,F)` with `L` valid patch centers; order & dimension must match the **training** setup.
- **Predictions:** columns are assumed `[w_phi, phi_x, phi_y, theta]` (if 4 outputs).

---

## Artifact Layout (example)

```
local_data/
  ├─ model.keras        # Keras SavedModel or .keras file
  ├─ scaler.pkl         # scikit-learn StandardScaler (or compatible)
  └─ meta.json          # {"predictorNameList": [...], "responseNameList": [...]}
```

- `predict_tf.py` enforces that the input DataFrame contains **all predictors** listed in `meta.json` and outputs a DataFrame with response names from the same meta.

---

## Repro Tips

- **Shape safety:** ensure the feature vector length `F` at inference equals the scaler’s length and the model’s input dimension.
- **FFT parity:** NumPy vs TF produce identical results **only** when FFT axes are aligned as in this code; avoid calling `tf.signal.fft2d` on `(N,M,L)` without the transpose.
- **Normalization:** the spectrum L1 norm is computed **per patch** before projection normalization.
- **Quality map:** works only where predictions exist (`M_proc`); elsewhere `QM=0`.

---

## Minimal Synthetic Demo

```python
import numpy as np
from ml_spatialfreq_utils import synth_fringe, calc_feature_batch

g, w_phi_gt, phi_x_gt, phi_y_gt, theta_gt = synth_fringe(
    NR=128, NC=128, w0_x=0.25, w0_y=0.10, psi=0.0, noise_std=0.02, return_maps=True
)

# Build a small stack of overlapping patches just for feature inspection
N=M=33
r=N//2; c=M//2
centers = [(64,64), (64,80), (80,64)]
B = np.stack([g[i-r:i-r+N, j-c:j-c+M] for (i,j) in centers], axis=2)  # (N,M,L)
X, S = calc_feature_batch(B, "feature_projected_DFT")
print(X.shape)  # -> (L, Wxp+N)
```

---

## License

Choose the most appropriate license for your use case (MIT, BSD‑3, Apache‑2.0, etc.).

---

## Citation

If you use this code or derivative work in research, please cite the repository and the corresponding report/paper from which the method is derived.



